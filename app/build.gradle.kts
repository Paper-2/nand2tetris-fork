/*
 * This file was generated by the Gradle 'init' task.
 */

plugins {
    id("buildlogic.java-application-conventions")
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17)) // For the project to be able to build it must use JDK 17.
    }
}

dependencies {
    implementation("org.apache.commons:commons-text")
    implementation(project(":utilities"))
}


// avoids making the default zip and tar
listOf("distZip", "distTar").forEach { t ->
    tasks.named(t).configure { enabled = false }
}

// Tasks to reproduce legacy install layout and zip it.
val installLayoutDir = layout.buildDirectory.dir("installLayout") // This will assign installLayoutDir to "build/installLayout"

val installLayout by tasks.registering(Sync::class) {
    dependsOn(tasks.classes) // Ensure classes are built first
    val legacyRoot = project.layout.projectDirectory.dir("src/main/resources/legacyResources") // Root of legacy resources to copy files from that don't need to be built
    val resources = project.layout.projectDirectory.dir("resources") // External libraries location
    // Compiled classes
    from(sourceSets.main.get().output) { into("bin/classes") }


    // Scripts & help expected under bin
    from(legacyRoot.dir("scripts")) { into("bin/scripts") } 
    from(legacyRoot.dir("help")) { into("bin/help") }

    // Other legacy assets at top-level (preserve relative paths used elsewhere)
    from(legacyRoot.dir("builtInChips")) { into("builtInChips") }
    from(legacyRoot.dir("builtInVMCode")) { into("builtInVMCode") }
    from(legacyRoot.dir("images")) { into("bin/images") }
    from(legacyRoot.dir("OS")) { into("OS") }

    // Also copy raw scripts/help at root if some code/paths rely on alternative locations
    from(legacyRoot.dir("scripts")) { into("scripts") }
    from(legacyRoot.dir("help")) { into("help") }

    into(installLayoutDir) // Final destination for the install layout
}

fun registerSubsetJar(name: String, baseName: String, includes: List<String>): TaskProvider<Jar> {
    return tasks.register(name, Jar::class.java) {
        archiveBaseName.set(baseName)
        from(sourceSets.main.get().output)
        includes.forEach { inc -> include("$inc/**") }
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    }
}

val hackJar = registerSubsetJar("hackJar", "Hack", listOf("Hack/ComputerParts", "Hack/Controller", "Hack/Events", "Hack/Translators", "Hack/Utilities"))
val hackGuiJar = registerSubsetJar("hackGuiJar", "HackGUI", listOf("HackGUI"))
val simulatorsJar = registerSubsetJar("simulatorsJar", "Simulators", listOf("Hack/CPUEmulator", "Hack/HardwareSimulator", "Hack/VMEmulator"))
val simulatorsGuiJar = registerSubsetJar("simulatorsGuiJar", "SimulatorsGUI", listOf("SimulatorsGUI"))
val compilersJar = registerSubsetJar("compilersJar", "Compilers", listOf("Hack/Assembler", "Hack/VirtualMachine"))
val translatorsGuiJar = registerSubsetJar("translatorsGuiJar", "TranslatorsGUI", listOf("Hack/Translators", "HackGUI"))
val assemblerGuiJar = registerSubsetJar("assemblerGuiJar", "AssemblerGUI", listOf("Hack/Assembler"))

val splitJars = tasks.register("splitJars") {
    group = "build"
    dependsOn(hackJar, hackGuiJar, simulatorsJar, simulatorsGuiJar, compilersJar, translatorsGuiJar, assemblerGuiJar)
}

val purgeInnerTools by tasks.registering(Delete::class) {
    delete(installLayoutDir.map { it.dir("tools") })
}

val augmentInstallLayout by tasks.registering(Copy::class) {
    description = "Add subset jars and promoted running scripts to install layout"
    dependsOn(installLayout, splitJars, tasks.named("processResources"), purgeInnerTools)
    into(installLayoutDir)

    // Add each subset jar into bin/lib
    listOf(hackJar, hackGuiJar, simulatorsJar, simulatorsGuiJar, compilersJar, translatorsGuiJar, assemblerGuiJar).forEach { jarTask ->
        from(jarTask.flatMap { it.archiveFile }) { into("bin/lib") }
    }

    from(installLayoutDir.map { it.dir("bin/classes/runningScripts") }) {
        include("*.bat", "*.sh")
        into("")
        duplicatesStrategy = DuplicatesStrategy.INCLUDE
    }


    // Only manually provided external libraries placed under src/main/resources/externalLibs (expected: junit & hamcrest)
    from(project.layout.projectDirectory.dir("src/main/resources/externalLibs")) {
        include("**/*.jar")
        into("bin/lib")
    }
}
// ----- Final distribution (CIS351 + installLayout reused as tools) -----
val cis351SourceDir = rootProject.layout.projectDirectory.dir("CIS351")
val finalDistRootDir = layout.buildDirectory.dir("finalDist")

val assembleFinalDistribution by tasks.registering(Sync::class) {
    group = "distribution"
    description = "Assemble final distribution root containing CIS351 and tools (installLayout reused)."
    // Ensure install layout is augmented before packaging
    dependsOn(augmentInstallLayout)
    from(cis351SourceDir) { into("CIS351") }
    from(installLayoutDir) { into("tools") }
    into(finalDistRootDir)
}

val fullDistZip by tasks.registering(Zip::class) {
    group = "distribution"
    description = "Zip the final distribution (CIS351 + tools)."
    dependsOn(assembleFinalDistribution)
    archiveBaseName.set("nand2tetris-CIS351")
    from(finalDistRootDir)
}

artifacts {
    add("archives", fullDistZip)
}